import argparse, time
import numpy as np
import onnxruntime as ort
import soundfile as sf
import torch

from src.data.prepare import wav_to_logmel, SAMPLE_RATE


def load_wav(path: str):
    audio, sr = sf.read(path, dtype="float32", always_2d=False)
    if audio.ndim == 1:
        audio = audio[np.newaxis, :]  # [1, N]
    else:
        audio = audio.T               # [C, N]
    wav = torch.from_numpy(audio)
    return wav, sr


def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--onnx", required=True, help="Path to .onnx model")
    ap.add_argument("--file", required=True, help="Path to .wav file")
    ap.add_argument("--iters", type=int, default=50,
                    help="How many runs to benchmark")
    args = ap.parse_args()

    # Load wav and preprocess
    wav, sr = load_wav(args.file)
    logmel = wav_to_logmel(wav, sr).unsqueeze(0).numpy()  # [1,1,64,T]

    # Setup ONNX runtime
    session = ort.InferenceSession(args.onnx, providers=["CPUExecutionProvider"])
    input_name = session.get_inputs()[0].name
    output_name = session.get_outputs()[0].name

    # Warmup
    for _ in range(5):
        session.run([output_name], {input_name: logmel})

    # Benchmark
    times = []
    for _ in range(args.iters):
        start = time.time()
        session.run([output_name], {input_name: logmel})
        times.append((time.time() - start) * 1000)  # ms

    times = np.array(times)
    print(f"Ran {args.iters} iterations")
    print(f"mean: {times.mean():.2f} ms")
    print(f"p50 : {np.percentile(times, 50):.2f} ms")
    print(f"p90 : {np.percentile(times, 90):.2f} ms")
    print(f"p99 : {np.percentile(times, 99):.2f} ms")


if __name__ == "__main__":
    main()
